---
import BaseLayout from "../layouts/BaseLayout.astro";
import { frames } from "../data/gallery.mjs";
// Build-time helpers to compute intrinsic image sizes to prevent layout shift
import sharp from "sharp";
import { fileURLToPath } from "node:url";

const base: string = import.meta.env.BASE_URL || "/";
const withBase = (p: string) => `${base}${p.replace(/^\//, "")}`;

// Resolve a file inside /public for build-time processing
const publicFileUrl = (publicPath: string) => new URL(`../../public${publicPath.replace(/^\//, "/")}`, import.meta.url);

// Compute width/height from the source image (WebP) at build time
const getMeta = async (src: string) => {
  try {
    const url = publicFileUrl(src);
    const meta = await sharp(fileURLToPath(url)).metadata();
    if (meta.width && meta.height) return { width: meta.width, height: meta.height };
  } catch (e) {
    // ignore; will fallback below
  }
  // Fallback ratio if metadata is unavailable
  return { width: 1600, height: 900 };
};

// Precompute render items with srcset and intrinsic sizes
const widths = [480, 720, 1080, 1440];
const sizes = "(min-width: 1600px) 20vw, (min-width: 1200px) 24vw, (min-width: 900px) 30vw, (min-width: 640px) 44vw, 94vw";
const items = await Promise.all(
  frames.map(async (f, i) => {
    const baseWebp = f.src.replace(/\.(jpe?g|png)$/i, ".webp");
    const { width, height } = await getMeta(baseWebp);
    const webpSrcset = widths
      .filter((w) => w <= width)
      .map((w) => `${withBase(baseWebp.replace(/\.webp$/, `.w${w}.webp`))} ${w}w`)
      .join(", ");
    return {
      index: i,
      alt: f.alt || `Frame ${i + 1}`,
      baseWebp,
      width,
      height,
      webpSrcset,
      sizes,
      credit: f.credit || "",
    };
  })
);
---

<BaseLayout title="Gallery" description="Collection of frames and stills taken from the videos.">
  <section class="gallery" aria-labelledby="gallery-heading">
    <header class="gallery__header">
      <p class="eyebrow">Frames</p>
      <h1 id="gallery-heading">Gallery</h1>
      <p>
        Selected frames from the videos. Click any image to view it larger.
      </p>
    </header>

    <ul class="gallery__grid" data-gallery>
      {items.map((it) => (
        <li class="gallery__item" data-index={it.index}>
          <figure class="frame is-loading" role="button" tabindex="0" aria-label={`Open image ${it.index + 1}`} style={`aspect-ratio: ${it.width} / ${it.height}` }>
            <picture>
              <source type="image/webp" srcset={it.webpSrcset} sizes={it.sizes} />
              <img
                src={withBase(it.baseWebp)}
                alt={it.alt}
                loading="lazy"
                decoding="async"
                sizes={it.sizes}
                width={it.width}
                height={it.height}
              />
            </picture>
            {it.alt && <figcaption class="frame__caption">{it.alt}{it.credit ? ` — ${it.credit}` : ""}</figcaption>}
          </figure>
        </li>
      ))}
    </ul>

    <div class="gallery__spotlight" data-spotlight aria-hidden="true">
      <svg class="gallery__spotlight-svg" data-spotlight-svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
        <defs>
          <mask id="spotMask" maskUnits="userSpaceOnUse">
            <rect x="0" y="0" width="100%" height="100%" fill="white" />
            <rect data-spotlight-hole x="0" y="0" width="0" height="0" rx="16" ry="16" fill="black" />
          </mask>
          <filter id="filmGrain" x="-20%" y="-20%" width="140%" height="140%">
            <feTurbulence type="fractalNoise" baseFrequency="0.5" numOctaves="3" stitchTiles="stitch">
              <animate attributeName="seed" from="0" to="100" dur="2.8s" repeatCount="indefinite" />
            </feTurbulence>
            <feColorMatrix type="saturate" values="0" />
          </filter>
          <radialGradient id="vignette" cx="50%" cy="50%" r="70%">
            <stop offset="60%" stop-color="#000" stop-opacity="0" />
            <stop offset="100%" stop-color="#000" stop-opacity="0.25" />
          </radialGradient>
        </defs>
        <g mask="url(#spotMask)">
          <rect x="0" y="0" width="100%" height="100%" fill="#000" opacity="0.48" />
          <rect x="0" y="0" width="100%" height="100%" fill="url(#vignette)" opacity="1" />
          <rect x="0" y="0" width="100%" height="100%" filter="url(#filmGrain)" opacity="0.18" />
        </g>
      </svg>
    </div>

    <div class="lightbox" data-lightbox aria-hidden="true">
      <button class="lightbox__close" type="button" aria-label="Close">✕</button>
      <button class="lightbox__nav lightbox__prev" type="button" aria-label="Previous">‹</button>
      <button class="lightbox__nav lightbox__next" type="button" aria-label="Next">›</button>
      <img class="lightbox__img" alt="" />
      <div class="lightbox__caption" data-caption></div>
    </div>
  </section>

  <style>
    .gallery {
      display: grid;
      gap: clamp(2rem, 5vw, 3rem);
    }

    .gallery__header {
      display: grid;
      gap: 1rem;
      max-width: 44rem;
    }

    .gallery__header h1 {
      margin: 0;
      font-family: var(--font-display);
      font-size: clamp(2.4rem, 6vw, 4rem);
      letter-spacing: 0.24em;
      text-transform: uppercase;
    }

    /* Masonry-style layout using CSS columns */
    .gallery__grid {
      list-style: none;
      margin: 0;
      padding: 0;
      column-gap: clamp(0.8rem, 2vw, 1.2rem);
      /* default column count adjusts with width */
      columns: 1 320px; /* min column width ~320px */
    }

    @media (min-width: 640px) {
      .gallery__grid { columns: 2 320px; }
    }
    @media (min-width: 900px) {
      .gallery__grid { columns: 3 320px; }
    }
    @media (min-width: 1200px) {
      .gallery__grid { columns: 4 320px; }
    }
    @media (min-width: 1600px) {
      .gallery__grid { columns: 5 340px; }
    }

    .gallery__item {
      display: inline-block;
      width: 100%;
      margin: 0 0 clamp(0.8rem, 2vw, 1.2rem);
      break-inside: avoid;
    }

    .frame {
      margin: 0;
      position: relative;
      border-radius: clamp(12px, 2vw, 16px);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.04);
      box-shadow: 0 14px 34px rgba(0,0,0,0.32);
      transition: box-shadow 260ms ease, filter 260ms ease;
      cursor: pointer; /* remove magnifying glass */
    }

    .frame:hover { box-shadow: 0 22px 54px rgba(0,0,0,0.38); }

    /* Skeleton shimmer to avoid perceived jank */
    .frame::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        linear-gradient(120deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02) 20%, rgba(255,255,255,0.08) 40%)
        0 0 / 240% 100% no-repeat,
        rgba(255,255,255,0.04);
      opacity: 0;
      transition: opacity 180ms ease;
    }
    .frame.is-loading::before { opacity: 1; animation: shimmer 1.4s infinite linear; }
    @keyframes shimmer {
      0% { background-position: -200% 0, 0 0; }
      100% { background-position: 200% 0, 0 0; }
    }

    /* Spotlight overlay outside images */
    .gallery__spotlight {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9998; /* below lightbox (9999), above content */
      opacity: 0;
      transition: opacity 900ms cubic-bezier(0.2, 0.8, 0.2, 1);
      background: transparent;
      display: none; /* disabled by default to save resources on mobile */
    }
    .gallery__spotlight[data-on="true"] { opacity: 1; }
    @media (hover: hover) and (pointer: fine) {
      .gallery__spotlight { display: block; }
    }
    .gallery__spotlight-svg { display: block; width: 100%; height: 100%; }

    :global([data-spotlight-hole]) {
      transition:
        x 280ms cubic-bezier(0.2, 0.8, 0.2, 1),
        y 280ms cubic-bezier(0.2, 0.8, 0.2, 1),
        width 280ms cubic-bezier(0.2, 0.8, 0.2, 1),
        height 280ms cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    .frame img {
      display: block;
      width: 100%;
      height: auto; /* keep natural aspect ratio */
      object-fit: cover; /* safe fallback */
      filter: saturate(0.98) contrast(1.02);
      opacity: 0;
      transition: opacity 240ms ease-out, filter 240ms ease-out;
    }
    .frame img.is-loaded { opacity: 1; }

    .frame__caption {
      position: absolute;
      inset: auto 0 0 0;
      padding: 0.65rem 0.9rem;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,0.8));
    }

    /* Lightbox */
    .lightbox {
      position: fixed;
      inset: 0;
      background: var(--bg-overlay, rgba(0,0,0,0.92));
      display: grid;
      place-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 180ms ease;
      z-index: 9999;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .lightbox.is-open {
      opacity: 1;
      pointer-events: auto;
    }
    .lightbox__img {
      max-width: 95vw;
      max-height: 90vh;
      width: auto;
      height: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      border-radius: clamp(8px, 1.5vw, 12px);
    }
    .lightbox__caption {
      position: fixed;
      left: 50%;
      bottom: max(12px, env(safe-area-inset-bottom));
      transform: translateX(-50%);
      color: #ddd;
      font-size: 0.9rem;
      padding: 0.4rem 0.8rem;
      background: rgba(0,0,0,0.46);
      border-radius: 8px;
      max-width: min(90vw, 60ch);
      text-align: center;
      backdrop-filter: blur(4px);
    }
    .lightbox__close {
      position: fixed;
      top: max(12px, env(safe-area-inset-top));
      right: max(12px, env(safe-area-inset-right));
      font-size: 18px;
      line-height: 1;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      background: linear-gradient(120deg, rgba(17,17,17,0.92), rgba(7,7,7,0.82));
      color: #fff;
      cursor: pointer;
      box-shadow: 0 18px 36px rgba(0,0,0,0.45);
      transition: transform 180ms ease, background 180ms ease, box-shadow 180ms ease;
    }
    .lightbox__close:hover,
    .lightbox__close:focus-visible {
      transform: translateY(-1px);
      background: linear-gradient(120deg, rgba(24,24,24,0.96), rgba(10,10,10,0.88));
      box-shadow: 0 24px 48px rgba(0,0,0,0.55);
    }
    .lightbox__nav {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px 14px;
      font-size: 24px;
      line-height: 1;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      background: linear-gradient(120deg, rgba(17,17,17,0.92), rgba(7,7,7,0.82));
      color: #fff;
      cursor: pointer;
      box-shadow: 0 18px 36px rgba(0,0,0,0.45);
      transition: transform 180ms ease, background 180ms ease, box-shadow 180ms ease;
      user-select: none;
    }
    .lightbox__nav:hover,
    .lightbox__nav:focus-visible {
      transform: translateY(calc(-50% - 1px));
      background: linear-gradient(120deg, rgba(24,24,24,0.96), rgba(10,10,10,0.88));
      box-shadow: 0 24px 48px rgba(0,0,0,0.55);
    }
    .lightbox__prev { left: max(12px, env(safe-area-inset-left)); }
    .lightbox__next { right: max(12px, env(safe-area-inset-right)); }
  </style>

  <script type="module">
    const gallery = document.querySelector('[data-gallery]');
    const items = Array.from(document.querySelectorAll('.gallery__item'));
    const images = Array.from(document.querySelectorAll('.frame img'));
    const lightbox = document.querySelector('[data-lightbox]');
    const imgEl = lightbox.querySelector('.lightbox__img');
    const captionEl = lightbox.querySelector('[data-caption]');
    const btnClose = lightbox.querySelector('.lightbox__close');
    const btnPrev = lightbox.querySelector('.lightbox__prev');
    const btnNext = lightbox.querySelector('.lightbox__next');
    const spotlight = document.querySelector('[data-spotlight]');
    const spotSvg = document.querySelector('[data-spotlight-svg]');
    const spotHole = spotSvg?.querySelector('[data-spotlight-hole]');

    let current = -1;

    // Move lightbox to body to escape any stacking contexts from gallery
    if (lightbox && document.body && lightbox.parentElement !== document.body) {
      document.body.appendChild(lightbox);
    }

    function openAt(index) {
      current = (index + images.length) % images.length;
      const img = images[current];
      const chosen = img.currentSrc || img.src;
      // Base full-size webp URL
      const baseUrl = chosen.replace(/\.w\d+\.webp$/i, '.webp');
      const naturalW = parseInt(img.getAttribute('width') || '0', 10) || 0;
      // Build high-res srcset limited to existing downscaled variants we keep
      const hiWidths = [1440];
      const candidates = [];
      for (const w of hiWidths) {
        if (naturalW >= w) candidates.push(`${baseUrl.replace(/\.webp$/i, `.w${w}.webp`)} ${w}w`);
      }
      // Always include the original master as the largest candidate
      if (naturalW > 0) candidates.push(`${baseUrl} ${naturalW}w`);

      imgEl.removeAttribute('srcset');
      imgEl.removeAttribute('sizes');
      if (candidates.length) {
        imgEl.srcset = candidates.join(', ');
        imgEl.sizes = '95vw';
      }
      imgEl.src = baseUrl; // fallback and immediate load
      imgEl.alt = img.alt || '';
      captionEl.textContent = img.alt || '';
      lightbox.classList.add('is-open');
      lightbox.setAttribute('aria-hidden', 'false');
      document.documentElement.style.overflow = 'hidden';
    }
    function close() {
      lightbox.classList.remove('is-open');
      lightbox.setAttribute('aria-hidden', 'true');
      imgEl.src = '';
      document.documentElement.style.overflow = '';
      current = -1;
    }
    function prev() { if (current !== -1) openAt(current - 1); }
    function next() { if (current !== -1) openAt(current + 1); }

    // Open by click or Enter
    items.forEach((li, idx) => {
      const fig = li.querySelector('.frame');
      fig?.addEventListener('click', () => openAt(idx));
      fig?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openAt(idx); }
      });
        if (spotlight && spotHole) {
          const updateSpotlight = () => {
            const rect = fig.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            const width = rect.width + 24;
            const height = rect.height + 24;
            spotHole.setAttribute('x', `${x - width / 2}`);
            spotHole.setAttribute('y', `${y - height / 2}`);
            spotHole.setAttribute('width', `${width}`);
            spotHole.setAttribute('height', `${height}`);
            spotlight.dataset.on = 'true';
          };
          const handleLeave = () => {
            delete spotlight.dataset.on;
          };
          fig.addEventListener('pointerenter', updateSpotlight);
          fig.addEventListener('pointermove', updateSpotlight);
          fig.addEventListener('pointerleave', handleLeave);
        }
    });

    // Controls
    btnClose.addEventListener('click', close);
    btnPrev.addEventListener('click', prev);
    btnNext.addEventListener('click', next);
    lightbox.addEventListener('click', (e) => {
      // close only when clicking the backdrop
      if (e.target === lightbox) close();
    });
    window.addEventListener('keydown', (e) => {
      if (lightbox.classList.contains('is-open')) {
        if (e.key === 'Escape') close();
        else if (e.key === 'ArrowLeft') prev();
        else if (e.key === 'ArrowRight') next();
      }
    });

    // Spotlight effect outside images
    const figures = Array.from(document.querySelectorAll('.frame'));
    let hoverFig = null;
    figures.forEach((fig) => {
      fig.addEventListener('pointerenter', () => {
        if (!spotlight || !spotHole) return;
        hoverFig = fig;
        const r = fig.getBoundingClientRect();
        const br = parseFloat(getComputedStyle(fig).borderTopLeftRadius) || 16;
        spotHole.setAttribute('x', `${r.left}`);
        spotHole.setAttribute('y', `${r.top}`);
        spotHole.setAttribute('width', `${r.width}`);
        spotHole.setAttribute('height', `${r.height}`);
        spotHole.setAttribute('rx', `${br}`);
        spotHole.setAttribute('ry', `${br}`);
        spotlight.dataset.on = 'true';
      });
      fig.addEventListener('pointerleave', () => {
        if (!spotlight || !spotHole) return;
        spotlight.dataset.on = 'false';
        spotHole.setAttribute('width', '0');
        spotHole.setAttribute('height', '0');
        hoverFig = null;
      });
    });
    const updateHole = () => {
      if (!hoverFig || spotlight?.dataset.on !== 'true' || !spotHole) return;
      const r = hoverFig.getBoundingClientRect();
      const br = parseFloat(getComputedStyle(hoverFig).borderTopLeftRadius) || 16;
      spotHole.setAttribute('x', `${r.left}`);
      spotHole.setAttribute('y', `${r.top}`);
      spotHole.setAttribute('width', `${r.width}`);
      spotHole.setAttribute('height', `${r.height}`);
      spotHole.setAttribute('rx', `${br}`);
      spotHole.setAttribute('ry', `${br}`);
    };
    window.addEventListener('scroll', updateHole);
    window.addEventListener('resize', updateHole);

    // Mark images as loaded to fade-in and hide skeletons; also handle cached images
    const markLoaded = (img) => {
      const fig = img.closest('.frame');
      fig?.classList.remove('is-loading');
      img.classList.add('is-loaded');
    };
    images.forEach((img) => {
      if (img.complete && img.naturalWidth > 0) {
        markLoaded(img);
      } else {
        img.addEventListener('load', () => markLoaded(img), { once: true });
      }
    });
  </script>
</BaseLayout>
